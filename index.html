

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HYPERLOOP: Gravity Flux ‚Äî Laptop Edition (for Parichay)</title>
  <style>
    :root { --bg:#04060e; --text:#eaf2ff; --ui:#0c1022; --accent:#67e8f9; --accent2:#a78bfa; --danger:#ef4444; }
    html, body { height:100%; }
    body { margin:0; background: radial-gradient(1200px 900px at 15% 10%, #080d22, var(--bg)); color:var(--text); font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; overflow:hidden; }
    #app { position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto; }
    #hud { display:flex; align-items:center; justify-content:space-between; padding:10px 14px; background:linear-gradient(90deg, rgba(167,139,250,0.12), rgba(103,232,249,0.10)); border-bottom:1px solid rgba(255,255,255,0.10); }
    .stats { display:flex; gap:10px; flex-wrap:wrap; font-weight:800; }
    .badge { padding:6px 10px; border-radius:999px; background:rgba(12,16,34,0.6); border:1px solid rgba(255,255,255,0.12); }
    .right { display:flex; gap:10px; align-items:center; }
    button { padding:10px 14px; border-radius:10px; border:1px solid rgba(255,255,255,0.2); color:var(--text); background:linear-gradient(180deg, rgba(103,232,249,0.25), rgba(167,139,250,0.25)); cursor:pointer; font-weight:800; letter-spacing:0.2px; }
    button.primary { background:linear-gradient(180deg, rgba(103,232,249,0.5), rgba(167,139,250,0.5)); }
    #canvas { width:100%; height:100%; display:block; }
    #overlay { position:absolute; inset:0; display:grid; place-items:center; pointer-events:auto; }
    .panel { max-width:900px; width:min(96vw, 900px); background:rgba(12,16,34,0.88); border:1px solid rgba(255,255,255,0.12); border-radius:16px; padding:18px 20px; box-shadow:0 20px 50px rgba(0,0,0,0.45); text-align:center; }
    .panel h1 { margin:6px 0; font-size: clamp(24px, 4vw, 32px); }
    .panel p { opacity:0.9; }
    .actions { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:12px; }
    #footer { padding:8px 14px; font-size:12px; opacity:0.85; background:rgba(12,16,34,0.4); }
  </style>
</head>
<body>
  <div id="app">
    <div id="hud">
      <div class="stats">
        <span class="badge" id="score">Score: 0</span>
        <span class="badge" id="speed">Speed: 0</span>
        <span class="badge" id="best">Best: 0</span>
        <span class="badge" id="portals">Gates: 0</span>
        <span class="badge" id="fps">FPS: 0</span>
      </div>
      <div class="right">
        <button id="pauseBtn">‚è∏Ô∏è Pause (P)</button>
        <button id="resetBtn">üîÑ Reset</button>
      </div>
    </div>

    <canvas id="canvas" aria-label="Gravity-Flip Shader Game"></canvas>

    <div id="overlay">
      <div class="panel" id="startPanel">
        <h1>HYPERLOOP: Gravity Flux</h1>
        <p>Flip gravity to dodge paradox obstacles inside a neon tunnel. Two lanes (ceiling/floor), warped geometry, impossible gates. Designed for laptop, runs offline. üîÅ‚ö°</p>
        <p><strong>Controls:</strong> A/D or ‚óÄ/‚ñ∂ steer ‚Ä¢ <strong>Space</strong> = Gravity Flip ‚Ä¢ <strong>Shift</strong> = Brake ‚Ä¢ <strong>P</strong> = Pause ‚Ä¢ <strong>C</strong> = Camera</p>
        <div class="actions">
          <button id="playBtn" class="primary">Play</button>
          <button id="howBtn">How to Play</button>
        </div>
      </div>
      <div class="panel" id="pausePanel" style="display:none;">
        <h1>Paused</h1>
        <p>Press <strong>P</strong> or tap Resume.</p>
        <div class="actions">
          <button id="resumeBtn" class="primary">Resume</button>
        </div>
      </div>
      <div class="panel" id="gameOverPanel" style="display:none;">
        <h1>Game Over</h1>
        <p id="finalScore">Score: 0</p>
        <p id="finalGates">Gates crossed: 0</p>
        <div class="actions">
          <button id="retryBtn" class="primary">Retry</button>
          <button id="shareBtn">Share</button>
        </div>
      </div>
    </div>

    <div id="footer">Tip: Flip just before gates to chain speed. Single HTML file, no libraries. If the screen is blank, enable Hardware Acceleration in your browser.</div>
  </div>

  <!-- Standalone WebGL shader game: gravity flip mechanic; offline. -->
  <script>
    const scoreEl = document.getElementById('score');
    const speedEl = document.getElementById('speed');
    const bestEl = document.getElementById('best');
    const portalsEl = document.getElementById('portals');
    const fpsEl = document.getElementById('fps');
    const overlay = document.getElementById('overlay');
    const startPanel = document.getElementById('startPanel');
    const pausePanel = document.getElementById('pausePanel');
    const gameOverPanel = document.getElementById('gameOverPanel');
    const playBtn = document.getElementById('playBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const retryBtn = document.getElementById('retryBtn');
    const shareBtn = document.getElementById('shareBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const howBtn = document.getElementById('howBtn');

    let best = parseFloat(localStorage.getItem('flux_best')||'0');
    bestEl.textContent = `Best: ${best.toFixed(1)}`;

    // --- WebGL setup ---
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    if(!gl){ alert('WebGL not supported. Try Chrome/Edge/Firefox, enable hardware acceleration.'); }
    function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0,0,gl.drawingBufferWidth, gl.drawingBufferHeight); }
    window.addEventListener('resize', resize);

    const vertSrc = `
      attribute vec2 a_pos;
      void main(){ gl_Position = vec4(a_pos, 0.0, 1.0); }
    `;

    const fragSrc = `
      precision highp float;
      uniform vec2 u_res;     // resolution
      uniform float u_time;   // time
      uniform float u_speed;  // forward speed
      uniform float u_playerX;// horizontal steering
      uniform float u_lane;   // -1 floor, +1 ceiling
      uniform float u_cam;    // 0 chase, 1 cockpit

      float hash(float n){ return fract(sin(n)*43758.5453); }

      // Space folding per segment
      vec3 fold(vec3 p){
        float seg = 20.0; // segment length
        float k = floor((p.z + 999.0)/seg);
        float ang = k*0.28;
        float ca = cos(ang), sa = sin(ang);
        mat2 R = mat2(ca,-sa,sa,ca);
        p.xy = R * p.xy;
        p.z = mod(p.z + 999.0, seg) - seg*0.5;
        return p;
      }

      // SDF helpers
      float sdTorus(vec3 p, vec2 t){ vec2 q = vec2(length(p.xz)-t.x, p.y); return length(q)-t.y; }
      float sdBox(vec3 p, vec3 b){ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }

      float scene(vec3 p, out vec3 color){
        vec3 q = fold(p);
        float d = 1e9; color = vec3(0.06,0.10,0.22);
        // tunnel
        float tunnel = length(q.xy) - 4.4; d = min(d, tunnel);
        // neon rim
        float rim = abs(length(q.xy)-4.0) - 0.06; if(rim<d){ color = vec3(0.40,0.92,0.96); } d = min(d, rim);
        // lanes
        float laneY = 1.6 * u_lane; float lane = length(vec2(q.x - u_playerX, q.y - laneY)) - 0.6; if(lane<d){ color = vec3(0.66,0.55,0.98); } d = min(d, lane);
        // gate near -6
        vec3 gp = q; gp.z += 6.0; float gate = sdTorus(gp, vec2(1.6, 0.10)); if(gate<d){ color = vec3(0.72,0.62,1.0); } d = min(d, gate);
        // obstacle near +4 with lane offset
        vec3 op = q; op.y -= laneY; op.z -= 4.0; op.x += sin((p.z+u_time*20.0)*0.08)*1.2; float obs = sdBox(op, vec3(0.9,0.6,0.8)); if(obs<d){ color = vec3(0.95,0.20,0.20);} d = min(d, obs);
        return d;
      }

      vec3 normalAt(vec3 p){ vec3 e=vec3(0.001,0.0,0.0), c; float d = scene(p,c); vec3 n;
        n.x = d - scene(p-e.xyy, c);
        n.y = d - scene(p-e.yxy, c);
        n.z = d - scene(p-e.yyx, c);
        return normalize(n);
      }

      vec3 render(vec3 ro, vec3 rd){ float t=0.0; vec3 col=vec3(0.0);
        for(int i=0;i<88;i++){
          vec3 p = ro + rd*t; vec3 mcol; float d = scene(p, mcol);
          if(d<0.001){ vec3 n = normalAt(p); float diff = max(dot(n, normalize(vec3(0.4,0.7,0.2))), 0.0);
            vec3 glow = mcol*0.6 + vec3(0.05,0.09,0.18);
            col = glow*(0.3+diff*0.7);
            return col; }
          t += d*0.6; if(t>60.0) break;
        }
        return vec3(0.01,0.02,0.06);
      }

      void main(){
        vec2 uv = (gl_FragCoord.xy - 0.5*u_res)/u_res.y;
        float fov = 1.0;
        vec3 ro = vec3(u_playerX*0.6, mix(0.2,0.8, step(0.5,u_cam)), u_time * u_speed * -1.0);
        vec3 ta = ro + vec3(0.0, 0.0, -1.0);
        vec3 fw = normalize(ta - ro);
        vec3 rt = normalize(vec3(1.0,0.0,0.0));
        vec3 up = normalize(cross(rt, fw)); rt = normalize(cross(fw, up));
        vec3 rd = normalize(fw*fov + rt*uv.x + up*uv.y);
        vec3 col = render(ro, rd);
        float vig = smoothstep(1.2, 0.2, length(uv));
        col = pow(col, vec3(0.95));
        gl_FragColor = vec4(col*vig, 1.0);
      }
    `;

    function makeShader(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); alert('Shader compile error'); } return s; }
    function makeProgram(vsrc, fsrc){ const p = gl.createProgram(); const vs = makeShader(gl.VERTEX_SHADER, vsrc); const fs = makeShader(gl.FRAGMENT_SHADER, fsrc); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); alert('Program link error'); } return p; }

    const prog = makeProgram(vertSrc, fragSrc); gl.useProgram(prog);
    const a_pos = gl.getAttribLocation(prog, 'a_pos');
    const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(a_pos); gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

    const u_res = gl.getUniformLocation(prog, 'u_res');
    const u_time = gl.getUniformLocation(prog, 'u_time');
    const u_speed = gl.getUniformLocation(prog, 'u_speed');
    const u_playerX = gl.getUniformLocation(prog, 'u_playerX');
    const u_lane = gl.getUniformLocation(prog, 'u_lane');
    const u_cam = gl.getUniformLocation(prog, 'u_cam');

    // --- Game state ---
    let running=false, paused=false, cam=0.0;
    let time=0, speed=6.0, maxSpeed=26.0;
    let playerX=0, score=0, gates=0, lane=-1.0; // start on floor; lane is -1 or +1
    let flipCooldown=0; // prevent flip spam

    function updateHUD(){ scoreEl.textContent=`Score: ${score.toFixed(1)}`; speedEl.textContent=`Speed: ${speed.toFixed(1)}`; portalsEl.textContent=`Gates: ${gates}`; }

    function resetGame(){ running=false; paused=false; time=0; speed=6.0; playerX=0; score=0; gates=0; lane=-1.0; flipCooldown=0; updateHUD(); overlay.style.pointerEvents='auto'; startPanel.style.display='block'; pausePanel.style.display='none'; gameOverPanel.style.display='none'; }
    function startGame(){ resetGame(); running=true; paused=false; overlay.style.pointerEvents='none'; startPanel.style.display='none'; }
    function gameOver(){ running=false; paused=false; overlay.style.pointerEvents='auto'; gameOverPanel.style.display='block'; document.getElementById('finalScore').textContent=`Score: ${score.toFixed(1)}`; document.getElementById('finalGates').textContent=`Gates crossed: ${gates}`; if(score>best){ best=score; localStorage.setItem('flux_best', String(best)); } bestEl.textContent=`Best: ${best.toFixed(1)}`; }
    function pauseGame(){ if(!running) return; paused=true; overlay.style.pointerEvents='auto'; pausePanel.style.display='block'; }
    function resumeGame(){ paused=false; overlay.style.pointerEvents='none'; pausePanel.style.display='none'; }

    // --- Input ---
    const keys = new Set();
    window.addEventListener('keydown', (e)=>{ const k=e.key.toLowerCase(); keys.add(k); if(k==='p'){ paused?resumeGame():pauseGame(); } if(k==='c'){ cam = (cam<0.5)?1.0:0.0; } });
    window.addEventListener('keyup', (e)=>{ keys.delete(e.key.toLowerCase()); });

    playBtn.addEventListener('click', startGame);
    resumeBtn.addEventListener('click', resumeGame);
    retryBtn.addEventListener('click', startGame);
    pauseBtn.addEventListener('click', ()=> paused?resumeGame():pauseGame());
    resetBtn.addEventListener('click', ()=> resetGame());
    shareBtn.addEventListener('click', async()=>{ const text = `I crossed ${gates} gates in HYPERLOOP: Gravity Flux with score ${score.toFixed(1)}!`; if(navigator.share){ try{ await navigator.share({ text, title:'HYPERLOOP: Gravity Flux' }); }catch(e){} } else { navigator.clipboard?.writeText(text); alert('Copied: '+text); } });
    howBtn.addEventListener('click', ()=> alert('Flip gravity with Space to switch between floor and ceiling lanes. Steer with A/D or ‚óÄ/‚ñ∂. Cross gates (neon rings) to score and speed up; avoid obstacles in your lane. Pause: P, Camera: C. Runs offline; enable hardware acceleration in browser if blank.'));

    // --- Audio (beeps) ---
    const AudioCtx = window.AudioContext || window.webkitAudioContext; const audioCtx = new AudioCtx(); let soundOn=true;
    function beep(freq, dur=0.08){ if(!soundOn) return; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type='sawtooth'; osc.frequency.value=freq; gain.gain.value=0.05; osc.connect(gain).connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+dur); }

    // --- Gameplay math ---
    const SEG_LEN = 20.0;
    function update(dt){ if(!running || paused) return; time += dt; const targetSpeed = Math.min(maxSpeed, 6 + time*0.6 + score*0.02); speed += (targetSpeed - speed)*0.02;
      const left = keys.has('arrowleft')||keys.has('a'); const right = keys.has('arrowright')||keys.has('d'); const braking = keys.has('shift');
      let steer = (right?1:0) - (left?1:0);
      if(braking){ speed = Math.max(3, speed - 20*dt); }
      playerX = Math.max(-2.8, Math.min(2.8, playerX + steer*dt*6.6));
      flipCooldown = Math.max(0, flipCooldown - dt);
      if((keys.has(' ')||keys.has('space')) && flipCooldown<=0){ lane = -lane; flipCooldown = 0.22; beep(520,0.09); }

      // world position along Z (negative forward)
      const worldZ = -time*speed; const idx = Math.floor((worldZ + 999.0)/SEG_LEN);
      const zLocal = ((worldZ + 999.0) % SEG_LEN) - SEG_LEN*0.5;

      // Gate at local z near +6 (shader uses gp.z += 6.0 -> gate visible ahead)
      if(Math.abs(zLocal - 6.0) < 0.12){ gates += 1; score += 4.0; speed += 2.0*dt; beep(440 + Math.random()*180, 0.10); }
      // Obstacle at local z near -4 (shader uses op.z -= 4.0)
      if(Math.abs(zLocal + 4.0) < 0.12){ const laneY = 1.6 * lane; // collision if x close and same lane
        // obstacle x drift function mirrors shader: sin((p.z+u_time*20)*0.08)*1.2
        const driftPhase = (worldZ + time*20.0)*0.08; const obsX = Math.sin(driftPhase)*1.2;
        const sameLane = true; // obstacle is centered in local lane space; lane check implicit by y
        if(Math.abs(playerX - obsX) < 0.95){ beep(160,0.15); return gameOver(); }
      }

      score += dt * (0.5 + speed*0.03); updateHUD();
    }

    // --- Render loop ---
    resize();
    let last = performance.now(); let fpsFrames=0, fpsTimer=0;
    function loop(now){ const dt = Math.min(0.05, (now-last)/1000); last = now; update(dt);
      gl.uniform2f(u_res, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.uniform1f(u_time, time);
      gl.uniform1f(u_speed, speed);
      gl.uniform1f(u_playerX, playerX);
      gl.uniform1f(u_lane, lane);
      gl.uniform1f(u_cam, cam);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      fpsFrames++; fpsTimer += dt; if(fpsTimer>=0.5){ fpsEl.textContent = `FPS: ${Math.round(fpsFrames/0.5)}`; fpsFrames=0; fpsTimer=0; }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Init
    updateHUD();
    window._gl = gl;
  </script>
</body>
</html>
