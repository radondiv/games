

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Neon Hover Racer 3D ‚Äî for Parichay</title>
  <style>
    :root {
      --bg: #05060f;
      --ui: #0c1022;
      --text: #eaf2ff;
      --accent: #67e8f9;
      --accent2: #a78bfa;
      --danger: #ef4444;
      --good: #22c55e;
    }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 900px at 15% 10%, #0a0e25, var(--bg));
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      color: var(--text);
      overflow: hidden;
    }
    #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr auto; }
    #hud {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 14px; background: linear-gradient(90deg, rgba(167,139,250,0.15), rgba(103,232,249,0.12));
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .stats { display: flex; gap: 10px; flex-wrap: wrap; font-weight: 700; }
    .badge { padding: 6px 10px; border-radius: 999px; background: rgba(12,16,34,0.7); border: 1px solid rgba(255,255,255,0.15); }
    .badge.good { border-color: rgba(34,197,94,0.6); }
    .badge.danger { border-color: rgba(239,68,68,0.6); }

    #canvas { display:block; width:100%; height:100%; }

    #overlay { position:absolute; inset:0; display:grid; place-items:center; pointer-events:auto; }
    .panel {
      max-width: 780px; width: min(94vw, 780px);
      background: rgba(12,16,34,0.85); border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px; padding: 18px 20px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.45);
      text-align: center;
    }
    .panel h1 { margin: 4px 0 6px; font-size: clamp(22px, 4vw, 28px); }
    .panel p { margin: 8px 0; opacity: 0.9; }
    .actions { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top: 12px; }
    button {
      padding: 10px 14px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2);
      color: var(--text); background: linear-gradient(180deg, rgba(103,232,249,0.25), rgba(167,139,250,0.25));
      cursor: pointer; font-weight: 800; letter-spacing: 0.2px;
    }
    button.primary { background: linear-gradient(180deg, rgba(103,232,249,0.5), rgba(167,139,250,0.5)); }

    #footer { padding: 8px 14px; font-size: 12px; opacity: 0.85; background: rgba(12,16,34,0.4); }

    .settings { display:flex; gap:10px; align-items:center; }
    .switch { display:flex; gap:8px; align-items:center; padding:6px 10px; border-radius: 999px; background: rgba(12,16,34,0.6); border:1px solid rgba(255,255,255,0.12); }
    .switch input { accent-color: #67e8f9; }

    /* Mobile controls */
    #mobileCtrls { position: absolute; inset:auto 0 14px 0; display:flex; justify-content:center; gap:10px; }
    .ctl { width: 90px; height: 90px; display:grid; place-items:center; border-radius: 14px; background: rgba(12,16,34,0.7); border: 1px solid rgba(255,255,255,0.12); font-weight: 900; }
    @media (min-width: 720px) { #mobileCtrls { display:none; } }
  </style>
</head>
<body>
  <div id="app">
    <div id="hud">
      <div class="stats">
        <span class="badge" id="score">Score: 0</span>
        <span class="badge" id="speed">Speed: 0</span>
        <span class="badge" id="best">Best: 0</span>
        <span class="badge" id="fps">FPS: 0</span>
      </div>
      <div class="settings">
        <label class="switch"><input type="checkbox" id="bloomToggle" checked/> Bloom</label>
        <label class="switch"><input type="checkbox" id="musicToggle" checked/> Music</label>
        <button id="pauseBtn">‚è∏Ô∏è Pause (P)</button>
        <button id="resetBtn">üîÑ Reset</button>
      </div>
    </div>
    <canvas id="canvas" aria-label="3D Game"></canvas>
    <div id="mobileCtrls">
      <div class="ctl" data-act="left">‚¨ÖÔ∏è</div>
      <div class="ctl" data-act="boost">‚ö°</div>
      <div class="ctl" data-act="right">‚û°Ô∏è</div>
    </div>
    <div id="overlay">
      <div class="panel" id="startPanel">
        <h1>Neon Hover Racer 3D</h1>
        <p>Steer a neon hovercraft through a procedural track, dodge obstacles, hit gates to score, and boost to survive. The track speeds up as you progress. üåå</p>
        <p><strong>Controls:</strong> A/D or ‚óÄ/‚ñ∂ steer ‚Ä¢ Space = Boost ‚Ä¢ Shift = Brake ‚Ä¢ P = Pause ‚Ä¢ C = Camera</p>
        <div class="actions">
          <button id="playBtn" class="primary">Play</button>
          <button id="howBtn">How to Play</button>
        </div>
      </div>
      <div class="panel" id="pausePanel" style="display:none;">
        <h1>Paused</h1>
        <p>Press <strong>P</strong> or tap Resume.</p>
        <div class="actions">
          <button id="resumeBtn" class="primary">Resume</button>
        </div>
      </div>
      <div class="panel" id="gameOverPanel" style="display:none;">
        <h1>Game Over</h1>
        <p id="finalScore">Score: 0</p>
        <div class="actions">
          <button id="retryBtn" class="primary">Retry</button>
          <button id="shareBtn">Share</button>
        </div>
      </div>
    </div>
    <div id="footer">Tip: Skim near gates to chain boosts. Your best score is saved locally.</div>
  </div>

  <!-- High-end 3D: Three.js + Bloom post-processing (CDN imports) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

    // ---- Globals & UI ----
    const canvas = document.getElementById('canvas');
    const scoreEl = document.getElementById('score');
    const speedEl = document.getElementById('speed');
    const bestEl = document.getElementById('best');
    const fpsEl = document.getElementById('fps');
    const overlay = document.getElementById('overlay');
    const startPanel = document.getElementById('startPanel');
    const pausePanel = document.getElementById('pausePanel');
    const gameOverPanel = document.getElementById('gameOverPanel');

    const bloomToggle = document.getElementById('bloomToggle');
    const musicToggle = document.getElementById('musicToggle');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const playBtn = document.getElementById('playBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const retryBtn = document.getElementById('retryBtn');
    const shareBtn = document.getElementById('shareBtn');

    let best = parseFloat(localStorage.getItem('neon_hover_best')||'0');
    bestEl.textContent = `Best: ${best.toFixed(1)}`;

    // ---- Scene ----
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060f);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3.2, 6.5);

    // Lights
    const hemi = new THREE.HemisphereLight(0xa1e1ff, 0x0a0e25, 0.9);
    scene.add(hemi);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Post-processing (Bloom)
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.4, 0.85);
    composer.addPass(bloomPass);

    function setBloomEnabled(enabled) {
      bloomPass.enabled = !!enabled;
    }

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // ---- Track & Environment ----
    const trackGroup = new THREE.Group(); scene.add(trackGroup);
    const obstacleGroup = new THREE.Group(); scene.add(obstacleGroup);
    const gateGroup = new THREE.Group(); scene.add(gateGroup);

    const trackWidth = 6; // x
    const segmentDepth = 24; // z length per segment
    const visibleSegments = 6;

    const matRoad = new THREE.MeshStandardMaterial({ color: 0x0f1430, metalness: 0.2, roughness: 0.9 });
    const matStripe = new THREE.MeshBasicMaterial({ color: 0x67e8f9 });

    const stripeGeo = new THREE.BoxGeometry(trackWidth, 0.02, 0.3);

    function makeSegment(zStart) {
      const g = new THREE.Group();
      const geom = new THREE.BoxGeometry(trackWidth, 0.2, segmentDepth);
      const road = new THREE.Mesh(geom, matRoad);
      road.position.set(0, 0, zStart);
      g.add(road);
      // neon edge stripes
      const s1 = new THREE.Mesh(stripeGeo, matStripe);
      s1.position.set(-trackWidth/2 + 0.15, 0.12, zStart - segmentDepth/2 + 0.3);
      const s2 = s1.clone(); s2.position.x = trackWidth/2 - 0.15;
      g.add(s1); g.add(s2);
      return g;
    }

    const segments = [];
    function initTrack() {
      trackGroup.clear(); segments.length = 0;
      for (let i=0;i<visibleSegments;i++) {
        const seg = makeSegment(-i * segmentDepth);
        segments.push(seg);
        trackGroup.add(seg);
      }
    }

    // Gates (score) & Obstacles
    const gateMat = new THREE.MeshBasicMaterial({ color: 0xa78bfa });
    const gateGeo = new THREE.TorusGeometry(1.2, 0.08, 16, 64);
    const obstacleGeo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
    const obstacleMat = new THREE.MeshStandardMaterial({ color: 0xef4444, metalness: 0.4, roughness: 0.3, emissive: 0x220000, emissiveIntensity: 0.4 });

    function spawnGate(z) {
      const gate = new THREE.Mesh(gateGeo, gateMat);
      gate.position.set((Math.random()*0.6-0.3)*trackWidth, 1.0, z);
      gate.rotation.x = Math.PI/2; gate.userData.type = 'gate';
      gateGroup.add(gate);
      return gate;
    }
    function spawnObstacle(z) {
      const m = new THREE.Mesh(obstacleGeo, obstacleMat);
      m.position.set((Math.random()*0.6-0.3)*trackWidth, 0.5, z);
      m.userData.type = 'obstacle';
      m.userData.phase = Math.random()*Math.PI*2; // sway animation
      obstacleGroup.add(m);
      return m;
    }

    // Populate initial gates/obstacles
    function regenDecor() {
      obstacleGroup.clear(); gateGroup.clear();
      for (let i=0;i<visibleSegments;i++) {
        const z = -i * segmentDepth;
        if (i%2===0) spawnGate(z - segmentDepth*0.5);
        if (i%2===1) spawnObstacle(z - segmentDepth*0.5);
      }
    }

    // ---- Player ----
    const craftGeo = new THREE.ConeGeometry(0.7, 1.6, 6);
    const craftMat = new THREE.MeshStandardMaterial({ color: 0x67e8f9, metalness: 0.7, roughness: 0.2, emissive: 0x081a20, emissiveIntensity: 0.8 });
    const craft = new THREE.Mesh(craftGeo, craftMat);
    craft.rotation.z = Math.PI; // nose forward
    craft.position.set(0, 0.9, 2.5);
    scene.add(craft);

    const auraGeo = new THREE.RingGeometry(0.9, 1.2, 32);
    const auraMat = new THREE.MeshBasicMaterial({ color: 0x67e8f9, side: THREE.DoubleSide });
    const aura = new THREE.Mesh(auraGeo, auraMat);
    aura.rotation.x = Math.PI/2; aura.position.y = 0.02; craft.add(aura);

    // Camera modes
    let camMode = 0; // 0 chase, 1 cockpit
    function updateCamera() {
      if (camMode===0) {
        camera.position.lerp(new THREE.Vector3(craft.position.x*0.5, 3.2, 6.5), 0.2);
        camera.lookAt(craft.position.x, 0.6, craft.position.z - 4);
      } else {
        camera.position.lerp(new THREE.Vector3(craft.position.x, 1.5, 2.0), 0.3);
        camera.lookAt(craft.position.x, 1.2, craft.position.z - 3);
      }
    }

    // ---- Game State ----
    let running = false;
    let paused = false;
    let score = 0;
    let speed = 6.0;     // forward speed (Z)
    let maxSpeed = 22.0; // clamp
    let steer = 0;       // input -1..1
    let boost = 0;       // boost charge 0..1
    let time = 0;        // sec

    function resetGame() {
      running = false; paused = false; score = 0; speed = 6.0; boost = 0; time = 0;
      craft.position.set(0, 0.9, 2.5);
      initTrack(); regenDecor();
      updateHUD();
    }

    function startGame() {
      resetGame();
      running = true; paused = false;
      overlay.style.pointerEvents = 'none';
      startPanel.style.display = 'none';
      pausePanel.style.display = 'none';
      gameOverPanel.style.display = 'none';
    }

    function gameOver() {
      running = false; paused = false;
      overlay.style.pointerEvents = 'auto';
      gameOverPanel.style.display = 'block';
      document.getElementById('finalScore').textContent = `Score: ${score.toFixed(1)}`;
      if (score > best) { best = score; localStorage.setItem('neon_hover_best', String(best)); }
      bestEl.textContent = `Best: ${best.toFixed(1)}`;
    }

    function pauseGame() { if (!running) return; paused = true; overlay.style.pointerEvents = 'auto'; pausePanel.style.display = 'block'; }
    function resumeGame() { paused = false; overlay.style.pointerEvents = 'none'; pausePanel.style.display = 'none'; }

    function updateHUD() {
      scoreEl.textContent = `Score: ${score.toFixed(1)}`;
      speedEl.textContent = `Speed: ${speed.toFixed(1)}`;
      bestEl.textContent = `Best: ${best.toFixed(1)}`;
    }

    // ---- Inputs ----
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      keys.add(e.key.toLowerCase());
      if (e.key.toLowerCase()==='p') { paused?resumeGame():pauseGame(); }
      if (e.key.toLowerCase()==='c') { camMode = (camMode+1)%2; }
    });
    window.addEventListener('keyup', (e) => { keys.delete(e.key.toLowerCase()); });

    document.querySelectorAll('#mobileCtrls .ctl').forEach(btn => {
      btn.addEventListener('touchstart', () => {
        const act = btn.getAttribute('data-act');
        if (act==='left') keys.add('arrowleft');
        if (act==='right') keys.add('arrowright');
        if (act==='boost') keys.add(' ');
      }, {passive:true});
      btn.addEventListener('touchend', () => {
        keys.delete('arrowleft'); keys.delete('arrowright'); keys.delete(' ');
      }, {passive:true});
    });

    playBtn.addEventListener('click', startGame);
    resumeBtn.addEventListener('click', resumeGame);
    retryBtn.addEventListener('click', startGame);
    shareBtn.addEventListener('click', async () => {
      const text = `I scored ${score.toFixed(1)} in Neon Hover Racer 3D!`;
      if (navigator.share) { try { await navigator.share({ text, title: 'Neon Hover Racer 3D' }); } catch(e){} }
      else { navigator.clipboard?.writeText(text); alert('Copied: '+text); }
    });
    pauseBtn.addEventListener('click', () => paused?resumeGame():pauseGame());
    resetBtn.addEventListener('click', () => { resetGame(); overlay.style.pointerEvents='auto'; startPanel.style.display='block'; pausePanel.style.display='none'; gameOverPanel.style.display='none'; });
    document.getElementById('howBtn').addEventListener('click', () => alert('Steer with A/D or ‚óÄ/‚ñ∂. Hold Space to boost (consumes charge), Shift to brake. Hit neon gates to gain score & refill boost. Avoid red obstacles. The track speeds up over time. Switch camera with C. Enjoy!'));

    bloomToggle.addEventListener('change', () => setBloomEnabled(bloomToggle.checked));
    musicToggle.addEventListener('change', () => setMusicEnabled(musicToggle.checked));

    // ---- Simple Music (WebAudio) ----
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioCtx();
    let musicOn = true; let gateOsc = null;
    function setMusicEnabled(on){ musicOn = on; if(!on) audioCtx.suspend(); else audioCtx.resume(); }
    function beep(freq, dur=0.08){ if(!musicOn) return; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type='sawtooth'; osc.frequency.value=freq; gain.gain.value=0.04; osc.connect(gain).connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+dur); }

    // ---- Gameplay Mechanics ----
    const tmpBox = new THREE.Box3();
    const craftBox = new THREE.Box3();

    function update(dt) {
      if (!running || paused) return;
      time += dt;

      // Difficulty scaling
      const targetSpeed = Math.min(maxSpeed, 6 + time*0.6 + score*0.02);
      speed = THREE.MathUtils.lerp(speed, targetSpeed, 0.02);

      // Input -> steer
      const left = keys.has('arrowleft') || keys.has('a');
      const right = keys.has('arrowright') || keys.has('d');
      steer = (right?1:0) - (left?1:0);

      // Boost & brake
      const boosting = keys.has(' ') || keys.has('space');
      const braking = keys.has('shift');
      if (boosting && boost>0) { speed += 12*dt; boost = Math.max(0, boost - 0.35*dt); aura.material.color.set(0xf97316); }
      else if (braking) { speed = Math.max(3, speed - 20*dt); aura.material.color.set(0x67e8f9); }
      else { aura.material.color.set(0x67e8f9); }

      // Craft hover feel: sway & clamp to track
      craft.position.x = THREE.MathUtils.clamp(craft.position.x + steer * dt * 6.2, -trackWidth/2+0.6, trackWidth/2-0.6);
      craft.position.z -= speed * dt; // world moves towards player (negative z)
      craft.rotation.y = THREE.MathUtils.lerp(craft.rotation.y, -steer*0.25, 0.15);
      craft.position.y = 0.9 + Math.sin(time*6)*0.03;

      // Move segments forward and recycle
      segments.forEach(seg => { seg.position.z += speed * dt; });
      for (let i=0;i<segments.length;i++) {
        const seg = segments[i];
        if (seg.position.z > segmentDepth*0.5) {
          seg.position.z -= segmentDepth*visibleSegments;
          // add new decor near recycled segment
          const z = seg.position.z - segmentDepth*0.5;
          if (Math.random() < 0.6) spawnGate(z);
          if (Math.random() < 0.6) spawnObstacle(z);
        }
      }

      // Animate obstacles & move gates/obstacles
      obstacleGroup.children.forEach(m => {
        m.userData.phase += dt*1.5;
        m.position.x = THREE.MathUtils.clamp(m.position.x + Math.sin(m.userData.phase)*0.02, -trackWidth/2+0.6, trackWidth/2-0.6);
        m.position.z += speed*dt;
      });
      gateGroup.children.forEach(g => { g.rotation.z += dt*1.5; g.position.z += speed*dt; });

      // Cull far behind objects
      obstacleGroup.children = obstacleGroup.children.filter(m => m.position.z < 6);
      gateGroup.children = gateGroup.children.filter(g => g.position.z < 6);

      // Collisions
      craftBox.setFromObject(craft);
      for (const m of obstacleGroup.children) {
        tmpBox.setFromObject(m);
        if (tmpBox.intersectsBox(craftBox)) {
          beep(160, 0.15); return gameOver();
        }
      }
      for (const g of gateGroup.children) {
        tmpBox.setFromObject(g);
        if (tmpBox.intersectsBox(craftBox)) {
          score += 3.5; boost = Math.min(1, boost + 0.45);
          gateGroup.remove(g);
          beep(440 + Math.random()*220, 0.10);
        }
      }

      // Scoring over time
      score += dt * (0.5 + speed*0.03);
      updateHUD();
    }

    // ---- Render loop ----
    let last = performance.now(); let accFps = 0; let fpsFrames=0; let fpsTimer=0;
    function loop(now) {
      const dt = Math.min(0.05, (now-last)/1000); last = now;
      update(dt);
      updateCamera();
      setBloomEnabled(bloomToggle.checked);
      composer.render();

      // FPS
      accFps += 1; fpsFrames += 1; fpsTimer += dt;
      if (fpsTimer >= 0.5) { fpsEl.textContent = `FPS: ${Math.round(accFps/0.5)}`; accFps=0; fpsTimer=0; }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Init world
    initTrack(); regenDecor(); updateHUD();

    // Expose for console debugging
    window._scene = scene; window._renderer = renderer;
  </script>
</body>
</html>
